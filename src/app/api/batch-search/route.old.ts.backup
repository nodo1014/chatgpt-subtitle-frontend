import { NextRequest, NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs';
import Database from 'better-sqlite3';

interface SubtitleData {
  media_file: string;
  text: string;
  start_time: string;
  end_time: string;
  language: string;
  directory: string;
}

interface SearchResult {
  media_file: string;
  subtitle_text: string;
  start_time: string;
  end_time: string;
  language: string;
  directory: string;
  confidence: number;
}

interface SentenceResult {
  sentence_index: number;
  search_sentence: string;
  found_count: number;
  results: SearchResult[];
}

// DB ì—°ê²° ìºì‹œ
let db: Database.Database | null = null;

function getDatabase(): Database.Database {
  if (!db) {
    const dbPath = path.join(process.cwd(), 'public', 'working_subtitles.db');
    db = new Database(dbPath, { readonly: true });
    console.log('ğŸ“Š DB ì—°ê²°ë¨:', dbPath);
  }
  return db;
}

export async function POST(request: NextRequest) {
  console.log('ğŸ” BATCH-SEARCH API í˜¸ì¶œë¨!');
  try {
    const { text, results_per_sentence = 20 } = await request.json();
    console.log('ğŸ“¥ ë°›ì€ ê²€ìƒ‰ í…ìŠ¤íŠ¸:', text);
    console.log('ğŸ“¥ ë¬¸ì¥ë‹¹ ê²°ê³¼ ìˆ˜:', results_per_sentence);

    if (!text || typeof text !== 'string') {
      return NextResponse.json({
        success: false,
        error: 'ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'
      }, { status: 400 });
    }

    // ì˜ì–´ ë¬¸ì¥ ì¶”ì¶œ
    const extractedSentences = extractEnglishSentences(text);
    
    if (extractedSentences.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'ì˜ì–´ ë¬¸ì¥ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê° ì¤„ì— í•˜ë‚˜ì”© ì˜ì–´ ë¬¸ì¥ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.'
      }, { status: 400 });
    }

    const sentenceResults: SentenceResult[] = [];
    let totalResults = 0;

    // ê° ë¬¸ì¥ì— ëŒ€í•´ DBì—ì„œ ê²€ìƒ‰ ìˆ˜í–‰
    for (let i = 0; i < extractedSentences.length; i++) {
      const sentence = extractedSentences[i];
      const searchResults = searchInDatabase(sentence, results_per_sentence);
      
      sentenceResults.push({
        sentence_index: i + 1,
        search_sentence: sentence,
        found_count: searchResults.length,
        results: searchResults
      });
      
      totalResults += searchResults.length;
    }

    // ì‘ë‹µ ë°ì´í„° êµ¬ì„±
    const responseData = {
      success: true,
      extracted_sentences: extractedSentences,
      search_summary: {
        total_sentences: extractedSentences.length,
        total_results: totalResults,
        average_per_sentence: (totalResults / extractedSentences.length).toFixed(1),
        search_time: 1.2 // ì‹¤ì œë¡œëŠ” ì¸¡ì •ëœ ì‹œê°„
      },
      sentence_results: sentenceResults,
      auto_create_clips: true
    };

    return NextResponse.json(responseData);

  } catch (error) {
    console.error('ë°°ì¹˜ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
    return NextResponse.json({
      success: false,
      error: 'ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    }, { status: 500 });
  }
}

function extractEnglishSentences(text: string): string[] {
  // í•œê¸€, í•œì, ì¼ë³¸ì–´ ë¬¸ì ì œê±° (ìœ ë‹ˆì½”ë“œ ë²”ìœ„)
  const koreanRegex = /[\u1100-\u11FF\u3130-\u318F\uAC00-\uD7AF\u4E00-\u9FFF\u3040-\u309F\u30A0-\u30FF]/g;
  
  // ì¤„ë°”ê¿ˆìœ¼ë¡œ ë¬¸ì¥ ë¶„ë¦¬
  const lines = text.split('\n').map(line => line.trim()).filter(line => {
    // ë¹ˆ ì¤„ ì œê±°
    if (line.length === 0) return false;
    
    // í•œê¸€/ì¤‘êµ­ì–´/ì¼ë³¸ì–´ ë¬¸ìê°€ í¬í•¨ëœ ì¤„ ì œê±°
    if (koreanRegex.test(line)) return false;
    
    // ìµœì†Œ ê¸¸ì´ ì²´í¬ (3ê¸€ì ì´ìƒ)
    if (line.length < 3) return false;
    
    // ìµœì†Œ ë‹¨ì–´ ìˆ˜ ì²´í¬ (1ê°œ ì´ìƒì˜ ë‹¨ì–´)
    if (line.split(/\s+/).length < 1) return false;
    
    return true;
  });
  
  return lines;
}

function searchInDatabase(query: string, limit: number): SearchResult[] {
  try {
    const database = getDatabase();
    const queryLower = query.toLowerCase().trim();
    
    console.log(`ğŸ” DB ê²€ìƒ‰: "${query}" (limit: ${limit})`);
    
    // FTSë¥¼ ì‚¬ìš©í•œ ê²€ìƒ‰ (ë” ì •í™•í•˜ê³  ë¹ ë¦„)
    const stmt = database.prepare(`
      SELECT s.media_file, s.text, s.start_time, s.end_time, s.language, s.directory,
             rank
      FROM subtitles_fts fts
      JOIN subtitles s ON s.id = fts.rowid
      WHERE fts.text MATCH ?
      ORDER BY rank
      LIMIT ?
    `);
    
    const results = stmt.all(query, limit);
    console.log(`ğŸ“Š DB ê²€ìƒ‰ ê²°ê³¼: ${results.length}ê°œ`);
    
    return results.map((row: any, index: number) => ({
      media_file: row.media_file,
      subtitle_text: row.text,
      start_time: row.start_time,
      end_time: row.end_time,
      language: row.language,
      directory: row.directory,
      confidence: Math.max(0.7, Math.min(1.0, 1.0 - (index * 0.05))) // ìˆœìœ„ì— ë”°ë¥¸ ì‹ ë¢°ë„
    }));

  } catch (error) {
    console.error('DB ê²€ìƒ‰ ì˜¤ë¥˜:', error);
    
    // í´ë°±: LIKE ê²€ìƒ‰
    try {
      const database = getDatabase();
      const stmt = database.prepare(`
        SELECT media_file, text, start_time, end_time, language, directory
        FROM subtitles 
        WHERE text LIKE ? COLLATE NOCASE
        ORDER BY media_file, start_time
        LIMIT ?
      `);
      
      const results = stmt.all(`%${query}%`, limit);
      console.log(`ğŸ“Š í´ë°± ê²€ìƒ‰ ê²°ê³¼: ${results.length}ê°œ`);
      
      return results.map((row: any, index: number) => ({
        media_file: row.media_file,
        subtitle_text: row.text,
        start_time: row.start_time,
        end_time: row.end_time,
        language: row.language,
        directory: row.directory,
        confidence: Math.max(0.6, Math.min(0.9, 0.9 - (index * 0.05)))
      }));
      
    } catch (fallbackError) {
      console.error('í´ë°± ê²€ìƒ‰ë„ ì‹¤íŒ¨:', fallbackError);
      return [];
    }
  }
} 