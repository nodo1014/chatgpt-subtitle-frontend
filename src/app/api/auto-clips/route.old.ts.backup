import { NextRequest, NextResponse } from 'next/server';
import { SearchResult, SentenceResult, ClipGenerationStats } from './types';
import { removeDuplicateResults } from './utils';
import { BatchProcessingService } from './batch.service';

// ì‹œê°„ ë¬¸ìì—´ì„ ì´ˆë¡œ ë³€í™˜
function timeToSeconds(timeStr: string): number {
  const parts = timeStr.split(':');
  const hours = parseInt(parts[0]);
  const minutes = parseInt(parts[1]);
  const secondsParts = parts[2].split(',');
  const seconds = parseInt(secondsParts[0]);
  const milliseconds = parseInt(secondsParts[1] || '0');
  
  return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
}

// íŒŒì¼ëª…ì—ì„œ ì œëª© ì¶”ì¶œ
function extractTitle(filePath: string): string {
  const fileName = path.basename(filePath, path.extname(filePath));
  
  // ì‹œë¦¬ì¦ˆ ì œëª© ì¶”ì¶œ (ì˜ˆ: "Batman The Animated Series (1992) - S01E01...")
  const seriesMatch = fileName.match(/^([^(]+(?:\([^)]+\))?)\s*-?\s*S\d+E\d+/);
  if (seriesMatch) {
    return seriesMatch[1].trim();
  }
  
  // ì˜í™” ì œëª© ì¶”ì¶œ
  const movieMatch = fileName.match(/^([^(]+(?:\([^)]+\))?)/);
  if (movieMatch) {
    return movieMatch[1].trim();
  }
  
  return fileName;
}

// íŒŒì¼ í¬ê¸° ì²´í¬ í•¨ìˆ˜
function checkFileSize(filePath: string): boolean {
  try {
    const stats = fs.statSync(filePath);
    const fileSizeGB = stats.size / (1024 * 1024 * 1024);
    
    if (fileSizeGB > MAX_FILE_SIZE_GB) {
      console.log(`ğŸ“ íŒŒì¼ í¬ê¸° ì´ˆê³¼: ${fileSizeGB.toFixed(2)}GB > ${MAX_FILE_SIZE_GB}GB - ìŠ¤í‚µ`);
      return false;
    }
    
    console.log(`ğŸ“ íŒŒì¼ í¬ê¸°: ${fileSizeGB.toFixed(2)}GB (í—ˆìš© ë²”ìœ„)`);
    return true;
  } catch (error) {
    console.log(`âŒ íŒŒì¼ í¬ê¸° í™•ì¸ ì‹¤íŒ¨: ${error}`);
    return false;
  }
}

// ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì²´í¬ í•¨ìˆ˜
function isBlacklistedFile(filePath: string): boolean {
  const fileName = path.basename(filePath);
  const isBlacklisted = PROBLEMATIC_FILES.some(blacklisted => fileName.includes(blacklisted));
  
  if (isBlacklisted) {
    console.log(`ğŸš« ë¸”ë™ë¦¬ìŠ¤íŠ¸ íŒŒì¼ ê°ì§€ - ìŠ¤í‚µ: ${fileName}`);
  }
  
  return isBlacklisted;
}

// í´ë¦½ ìƒì„± (ìµœì í™”ëœ ì„¤ì •)
async function createClip(mediaFile: string, startTime: string, endTime: string, outputPath: string): Promise<boolean> {
  // ì‚¬ì „ ì²´í¬: ë¸”ë™ë¦¬ìŠ¤íŠ¸ ë° íŒŒì¼ í¬ê¸°
  if (isBlacklistedFile(mediaFile)) {
    return false;
  }
  
  if (!checkFileSize(mediaFile)) {
    return false;
  }
  
  return new Promise((resolve) => {
    const startSeconds = timeToSeconds(startTime);
    const endSeconds = timeToSeconds(endTime);
    const duration = endSeconds - startSeconds;
    
    console.log(`ğŸ”§ FFmpeg ëª…ë ¹ì–´ ì‹¤í–‰:`);
    console.log(`   ì…ë ¥: ${mediaFile}`);
    console.log(`   ì‹œì‘: ${startSeconds}ì´ˆ, ê¸¸ì´: ${duration}ì´ˆ`);
    console.log(`   ì¶œë ¥: ${outputPath}`);
    
    const startTime_process = Date.now();
    
    // 60ì´ˆ íƒ€ì„ì•„ì›ƒ ì„¤ì • (ë” ì—¬ìœ ë¡­ê²Œ)
    const timeout = setTimeout(() => {
      console.log(`â° FFmpeg íƒ€ì„ì•„ì›ƒ (60ì´ˆ) - ê°•ì œ ì¢…ë£Œ: ${mediaFile}`);
      ffmpeg.kill('SIGKILL');
      resolve(false);
    }, BATCH_CONFIG.CLIP_TIMEOUT);
    
    // ë” ì•ˆì •ì ì¸ FFmpeg ëª…ë ¹ì–´ (copy ì½”ë± ìš°ì„  ì‹œë„)
    const ffmpeg = spawn('ffmpeg', [
      '-i', mediaFile,
      '-ss', startSeconds.toString(),
      '-t', duration.toString(),
      '-c:v', 'copy',              // ë¹„ë””ì˜¤ ë³µì‚¬ (ì¬ì¸ì½”ë”© ì—†ìŒ, ê°€ì¥ ë¹ ë¦„)
      '-c:a', 'copy',              // ì˜¤ë””ì˜¤ ë³µì‚¬ (ì¬ì¸ì½”ë”© ì—†ìŒ, ê°€ì¥ ë¹ ë¦„)
      '-avoid_negative_ts', 'make_zero', // íƒ€ì„ìŠ¤íƒ¬í”„ ë¬¸ì œ ë°©ì§€
      '-y',                        // ê¸°ì¡´ íŒŒì¼ ë®ì–´ì“°ê¸°
      outputPath
    ], {
      stdio: ['ignore', 'pipe', 'pipe'] // stdout, stderr ìº¡ì²˜
    });
    
    let stdout = '';
    let stderr = '';
    let lastProgressTime = Date.now();
    
    ffmpeg.stdout?.on('data', (data) => {
      stdout += data.toString();
      lastProgressTime = Date.now();
    });
    
    ffmpeg.stderr?.on('data', (data) => {
      const chunk = data.toString();
      stderr += chunk;
      lastProgressTime = Date.now();
      
      // ì§„í–‰ë¥  ì •ë³´ ì¶”ì¶œ ë° ì¶œë ¥
      if (chunk.includes('time=')) {
        const timeMatch = chunk.match(/time=(\d{2}:\d{2}:\d{2}\.\d{2})/);
        if (timeMatch) {
          console.log(`â³ FFmpeg ì§„í–‰ ì¤‘... í˜„ì¬ ì‹œê°„: ${timeMatch[1]}`);
        }
      }
    });
    
    // ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§ (10ì´ˆë§ˆë‹¤ ì²´í¬)
    const progressMonitor = setInterval(() => {
      const timeSinceLastProgress = Date.now() - lastProgressTime;
      const totalTime = Date.now() - startTime_process;
      
      if (timeSinceLastProgress > 15000) { // 15ì´ˆ ë™ì•ˆ ì§„í–‰ ì—†ìŒ
        console.log(`âš ï¸ FFmpeg ì§„í–‰ ì •ì§€ ê°ì§€ (${timeSinceLastProgress/1000}ì´ˆ ë¬´ì‘ë‹µ)`);
        console.log(`ğŸ“Š ì´ ê²½ê³¼ ì‹œê°„: ${totalTime/1000}ì´ˆ`);
        console.log(`ğŸ“ ì²˜ë¦¬ ì¤‘ì¸ íŒŒì¼: ${mediaFile}`);
      }
    }, 10000);
    
    ffmpeg.on('close', (code) => {
      clearTimeout(timeout);
      clearInterval(progressMonitor);
      
      const totalTime = Date.now() - startTime_process;
      
      if (code === 0) {
        console.log(`âœ… FFmpeg ì„±ê³µ (ì½”ë“œ: ${code}, ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ)`);
        console.log(`ğŸ“ í´ë¦½ íŒŒì¼ ìƒì„±: ${outputPath}`);
      } else {
        console.log(`âŒ FFmpeg ì‹¤íŒ¨ (ì½”ë“œ: ${code}, ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ)`);
        console.log(`ğŸ“ ì‹¤íŒ¨í•œ íŒŒì¼: ${mediaFile}`);
        console.log(`ğŸ“ stderr (ë§ˆì§€ë§‰ 1000ì): ${stderr.slice(-1000)}`);
        
        // copy ì½”ë± ì‹¤íŒ¨ ì‹œ ì¬ì¸ì½”ë”©ìœ¼ë¡œ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ (ì‹œê°„ ì ˆì•½)
        console.log(`ğŸ’¡ copy ì½”ë± ì‹¤íŒ¨ - ì´ íŒŒì¼ì€ ìŠ¤í‚µí•©ë‹ˆë‹¤ (ì¬ì¸ì½”ë”© ì‹œê°„ ì ˆì•½)`);
      }
      resolve(code === 0);
    });
    
    ffmpeg.on('error', (error) => {
      clearTimeout(timeout);
      clearInterval(progressMonitor);
      
      const totalTime = Date.now() - startTime_process;
      console.log(`âŒ FFmpeg í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ (ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ): ${error}`);
      console.log(`ğŸ“ ì˜¤ë¥˜ ë°œìƒ íŒŒì¼: ${mediaFile}`);
      resolve(false);
    });
  });
}

// ì¸ë„¤ì¼ ìƒì„± (ë°ê¸° ë° ëŒ€ë¹„ í–¥ìƒ)
async function createThumbnail(mediaFile: string, timeStr: string, thumbnailPath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const seconds = timeToSeconds(timeStr);
    
    console.log(`ğŸ–¼ï¸ ì¸ë„¤ì¼ FFmpeg ëª…ë ¹ì–´ ì‹¤í–‰:`);
    console.log(`   ì…ë ¥: ${mediaFile}`);
    console.log(`   ì‹œê°„: ${seconds}ì´ˆ`);
    console.log(`   ì¶œë ¥: ${thumbnailPath}`);
    
    const startTime_process = Date.now();
    
    // 45ì´ˆ íƒ€ì„ì•„ì›ƒ ì„¤ì • (í´ë¦½ê³¼ ë™ì¼í•˜ê²Œ ì¦ê°€)
    const timeout = setTimeout(() => {
      console.log(`â° ì¸ë„¤ì¼ FFmpeg íƒ€ì„ì•„ì›ƒ (45ì´ˆ) - ê°•ì œ ì¢…ë£Œ: ${mediaFile}`);
      ffmpeg.kill('SIGKILL');
      resolve(false);
    }, BATCH_CONFIG.THUMBNAIL_TIMEOUT);
    
    // ë” ê°„ë‹¨í•œ ì¸ë„¤ì¼ ìƒì„± ëª…ë ¹ì–´ (ë³µì¡í•œ í•„í„° ì œê±°)
    const ffmpeg = spawn('ffmpeg', [
      '-i', mediaFile,
      '-ss', seconds.toString(),
      '-vframes', '1',
      '-vf', 'scale=320:180:force_original_aspect_ratio=decrease,pad=320:180:(ow-iw)/2:(oh-ih)/2', // í•„í„° ë‹¨ìˆœí™”
      '-q:v', '3', // í’ˆì§ˆ ê³ ì • (ë” ì•ˆì •ì )
      '-y',
      thumbnailPath
    ], {
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    let stderr = '';
    let stdout = '';
    let lastProgressTime = Date.now();
    
    ffmpeg.stdout?.on('data', (data) => {
      stdout += data.toString();
      lastProgressTime = Date.now();
    });
    
    ffmpeg.stderr?.on('data', (data) => {
      const chunk = data.toString();
      stderr += chunk;
      lastProgressTime = Date.now();
      
      // ì¸ë„¤ì¼ ì§„í–‰ë¥  ë¡œê·¸
      if (chunk.includes('frame=')) {
        console.log(`ğŸ–¼ï¸ ì¸ë„¤ì¼ ì§„í–‰ ì¤‘: ${chunk.trim()}`);
      }
    });
    
    // ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§ (5ì´ˆë§ˆë‹¤ ì²´í¬)
    const progressMonitor = setInterval(() => {
      const timeSinceLastProgress = Date.now() - lastProgressTime;
      const totalTime = Date.now() - startTime_process;
      
      if (timeSinceLastProgress > 10000) { // 10ì´ˆ ë™ì•ˆ ì§„í–‰ ì—†ìŒ
        console.log(`âš ï¸ ì¸ë„¤ì¼ FFmpeg ì§„í–‰ ì •ì§€ ê°ì§€ (${timeSinceLastProgress/1000}ì´ˆ ë¬´ì‘ë‹µ)`);
        console.log(`ğŸ“Š ì´ ê²½ê³¼ ì‹œê°„: ${totalTime/1000}ì´ˆ`);
        console.log(`ğŸ“ ì²˜ë¦¬ ì¤‘ì¸ íŒŒì¼: ${mediaFile}`);
      }
    }, 5000);
    
    ffmpeg.on('close', (code) => {
      clearTimeout(timeout);
      clearInterval(progressMonitor);
      
      const totalTime = Date.now() - startTime_process;
      
      if (code === 0) {
        console.log(`âœ… ì¸ë„¤ì¼ FFmpeg ì„±ê³µ (ì½”ë“œ: ${code}, ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ)`);
        console.log(`ğŸ“ ì¸ë„¤ì¼ íŒŒì¼ ìƒì„±: ${thumbnailPath}`);
      } else {
        console.log(`âŒ ì¸ë„¤ì¼ FFmpeg ì‹¤íŒ¨ (ì½”ë“œ: ${code}, ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ)`);
        console.log(`ğŸ“ ì‹¤íŒ¨í•œ íŒŒì¼: ${mediaFile}`);
        console.log(`ğŸ“ stderr (ë§ˆì§€ë§‰ 500ì): ${stderr.slice(-500)}`);
        console.log(`ğŸ“ stdout (ë§ˆì§€ë§‰ 300ì): ${stdout.slice(-300)}`);
      }
      resolve(code === 0);
    });
    
    ffmpeg.on('error', (error) => {
      clearTimeout(timeout);
      clearInterval(progressMonitor);
      
      const totalTime = Date.now() - startTime_process;
      console.log(`âŒ ì¸ë„¤ì¼ FFmpeg í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ (ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ): ${error}`);
      console.log(`ğŸ“ ì˜¤ë¥˜ ë°œìƒ íŒŒì¼: ${mediaFile}`);
      resolve(false);
    });
  });
}

// ìë™ í´ë¦½ ìƒì„±
async function autoCreateClip(sentence: string, result: SearchResult): Promise<ClipMetadata | null> {
  const clipStartTime = Date.now();
  
  try {
    console.log(`ğŸ¬ í´ë¦½ ìƒì„± ì‹œì‘ - ë¬¸ì¥: ${sentence.substring(0, 50)}...`);
    console.log(`ğŸ“¹ ì†ŒìŠ¤: ${result.media_file} (${result.start_time} ~ ${result.end_time})`);
    console.log(`â° ì‹œì‘ ì‹œê°„: ${new Date().toLocaleTimeString()}`);
    
    // ë™ì¼í•œ í´ë¦½ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    const clipsDir = MEDIA_CONFIG.CLIPS_OUTPUT_PATH;
    const existingFiles = await fs.promises.readdir(clipsDir).catch(() => []);
    
    // ê¸°ì¡´ ë©”íƒ€ë°ì´í„° íŒŒì¼ë“¤ì„ í™•ì¸í•˜ì—¬ ì¤‘ë³µ ë°©ì§€
    for (const file of existingFiles) {
      if (file.endsWith('.json')) {
        try {
          const metadataPath = path.join(clipsDir, file);
          const existingMetadata = JSON.parse(await fs.promises.readFile(metadataPath, 'utf-8'));
          
          // ë™ì¼í•œ ë¯¸ë””ì–´ íŒŒì¼, ì‹œì‘/ì¢…ë£Œ ì‹œê°„ì¸ ê²½ìš° ì¤‘ë³µìœ¼ë¡œ ê°„ì£¼
          if (existingMetadata.sourceFile === result.media_file &&
              existingMetadata.startTime === result.start_time &&
              existingMetadata.endTime === result.end_time) {
            console.log(`ğŸ”„ ì¤‘ë³µ í´ë¦½ ê°ì§€, ê¸°ì¡´ í´ë¦½ ë°˜í™˜: ${existingMetadata.title}`);
            console.log(`   ê¸°ì¡´: ${existingMetadata.sourceFile} (${existingMetadata.startTime} ~ ${existingMetadata.endTime})`);
            console.log(`   ìš”ì²­: ${result.media_file} (${result.start_time} ~ ${result.end_time})`);
            return existingMetadata;
          }
        } catch {
          // ë©”íƒ€ë°ì´í„° íŒŒì¼ ì½ê¸° ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
          continue;
        }
      }
    }
    
    const clipId = uuidv4();
    const title = extractTitle(result.media_file);
    
    // Configë¥¼ ì‚¬ìš©í•œ íŒŒì¼ ê²½ë¡œ ì„¤ì •
    const clipPath = getClipOutputPath(clipId);
    const thumbnailPath = getThumbnailOutputPath(clipId);
    const mediaFilePath = getMediaFilePath(result.media_file, result.directory);
    const metadataPath = path.join(MEDIA_CONFIG.CLIPS_OUTPUT_PATH, `${clipId}.json`);
    
    console.log(`ğŸ“ ë¯¸ë””ì–´ íŒŒì¼ ê²½ë¡œ: ${mediaFilePath}`);
    console.log(`ğŸ“ í´ë¦½ ì¶œë ¥ ê²½ë¡œ: ${clipPath}`);
    console.log(`ğŸ“ ì¸ë„¤ì¼ ì¶œë ¥ ê²½ë¡œ: ${thumbnailPath}`);
    console.log(`ğŸ“ ë©”íƒ€ë°ì´í„° ê²½ë¡œ: ${metadataPath}`);
    
    // 1ë‹¨ê³„: JSON ë©”íƒ€ë°ì´í„° ë¨¼ì € ìƒì„± (ì¤‘ë³µ ë°©ì§€ ë° ì§„í–‰ ìƒí™© ì¶”ì )
    const initialMetadata: ClipMetadata = {
      id: clipId,
      title,
      sentence: result.subtitle_text,
      englishSubtitle: result.subtitle_text,
      koreanSubtitle: `í•œê¸€ ë²ˆì—­: ${sentence}`,
      startTime: result.start_time,
      endTime: result.end_time,
      sourceFile: result.media_file,
      clipPath: getClipWebPath(clipId),
      thumbnailPath: undefined, // ì•„ì§ ìƒì„±ë˜ì§€ ì•ŠìŒ
      createdAt: new Date().toISOString(),
      duration: `${timeToSeconds(result.end_time) - timeToSeconds(result.start_time)}ì´ˆ`,
      tags: [title.split(' ')[0], 'auto-generated', 'processing'] // ì²˜ë¦¬ ì¤‘ í‘œì‹œ
    };
    
    try {
      // JSON íŒŒì¼ ë¨¼ì € ìƒì„± (ì¦‰ì‹œ ì¤‘ë³µ ë°©ì§€ íš¨ê³¼)
      await fs.promises.writeFile(metadataPath, JSON.stringify(initialMetadata, null, 2));
      console.log(`ğŸ“ JSON ë©”íƒ€ë°ì´í„° ë¨¼ì € ìƒì„±: ${metadataPath}`);
      
      // 2ë‹¨ê³„: ë¯¸ë””ì–´ íŒŒì¼ ì¡´ì¬ í™•ì¸
      console.log(`ğŸ” ë¯¸ë””ì–´ íŒŒì¼ ì¡´ì¬ í™•ì¸ ì¤‘...`);
      try {
        const stats = await fs.promises.stat(mediaFilePath);
        if (stats.isFile()) {
          console.log(`âœ… ë¯¸ë””ì–´ íŒŒì¼ í™•ì¸ë¨: ${mediaFilePath} (í¬ê¸°: ${Math.round(stats.size / 1024 / 1024)}MB)`);
        } else {
          console.log(`âŒ ê²½ë¡œê°€ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: ${mediaFilePath}`);
          // ì‹¤íŒ¨ ì‹œ JSON íŒŒì¼ ì‚­ì œ
          await fs.promises.unlink(metadataPath);
          return null;
        }
      } catch (error) {
        console.log(`âŒ ë¯¸ë””ì–´ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${mediaFilePath}`);
        console.log(`ğŸ” ì˜¤ë¥˜ ìƒì„¸: ${error}`);
        // ì‹¤íŒ¨ ì‹œ JSON íŒŒì¼ ì‚­ì œ
        await fs.promises.unlink(metadataPath);
        return null;
      }

      // 3ë‹¨ê³„: JSON ê¸°ë°˜ìœ¼ë¡œ MP4 í´ë¦½ ìƒì„±
      console.log(`ğŸ¬ JSON ê¸°ë°˜ í´ë¦½ ìƒì„± ì‹œì‘: ${clipId}`);
      const clipCreateStartTime = Date.now();
      const clipSuccess = await createClip(mediaFilePath, result.start_time, result.end_time, clipPath);
      const clipCreateTime = Date.now() - clipCreateStartTime;

      if (!clipSuccess) {
        console.log(`âŒ í´ë¦½ ìƒì„± ì‹¤íŒ¨: ${result.media_file} (ì†Œìš”ì‹œê°„: ${clipCreateTime/1000}ì´ˆ)`);
        // ì‹¤íŒ¨ ì‹œ JSON íŒŒì¼ ì‚­ì œ
        await fs.promises.unlink(metadataPath);
        return null;
      }

      console.log(`âœ… í´ë¦½ ìƒì„± ì„±ê³µ: ${clipPath} (ì†Œìš”ì‹œê°„: ${clipCreateTime/1000}ì´ˆ)`);
      
      // 4ë‹¨ê³„: ì¸ë„¤ì¼ ìƒì„±
      console.log(`ğŸ–¼ï¸ ì¸ë„¤ì¼ ìƒì„± ì‹œì‘: ${clipId}`);
      const thumbnailCreateStartTime = Date.now();
      const thumbnailSuccess = await createThumbnail(mediaFilePath, result.start_time, thumbnailPath);
      const thumbnailCreateTime = Date.now() - thumbnailCreateStartTime;
      
      console.log(`${thumbnailSuccess ? 'âœ…' : 'âŒ'} ì¸ë„¤ì¼ ìƒì„±: ${thumbnailPath} (ì†Œìš”ì‹œê°„: ${thumbnailCreateTime/1000}ì´ˆ)`);
      
      // 5ë‹¨ê³„: JSON ë©”íƒ€ë°ì´í„° ìµœì¢… ì—…ë°ì´íŠ¸ (processing íƒœê·¸ ì œê±°, ì¸ë„¤ì¼ ê²½ë¡œ ì¶”ê°€)
      const finalMetadata: ClipMetadata = {
        ...initialMetadata,
        thumbnailPath: thumbnailSuccess ? getThumbnailWebPath(clipId) : undefined,
        tags: [title.split(' ')[0], 'auto-generated'] // processing íƒœê·¸ ì œê±°
      };
      
      await fs.promises.writeFile(metadataPath, JSON.stringify(finalMetadata, null, 2));
      
      const totalTime = Date.now() - clipStartTime;
      console.log(`ğŸ‰ í´ë¦½ ìƒì„± ì™„ë£Œ: ${title} (ì´ ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ)`);
      console.log(`   - í´ë¦½ ìƒì„±: ${clipCreateTime/1000}ì´ˆ`);
      console.log(`   - ì¸ë„¤ì¼ ìƒì„±: ${thumbnailCreateTime/1000}ì´ˆ`);
      console.log(`â° ì™„ë£Œ ì‹œê°„: ${new Date().toLocaleTimeString()}`);
      
      return finalMetadata;
      
    } catch (error) {
      console.log(`âŒ í´ë¦½ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error}`);
      console.log(`ğŸ“ ì˜¤ë¥˜ ë°œìƒ íŒŒì¼: ${result.media_file}`);
      
      // ì‹¤íŒ¨ ì‹œ ìƒì„±ëœ íŒŒì¼ë“¤ ì •ë¦¬
      try {
        await fs.promises.unlink(metadataPath);
        await fs.promises.unlink(clipPath);
        await fs.promises.unlink(thumbnailPath);
      } catch {
        // íŒŒì¼ ì‚­ì œ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ
      }
      
      return null;
    }
    
  } catch (error) {
    const totalTime = Date.now() - clipStartTime;
    console.log(`âŒ í´ë¦½ ìƒì„± ì „ì²´ ì‹¤íŒ¨: ${error} (ì†Œìš”ì‹œê°„: ${totalTime/1000}ì´ˆ)`);
    console.log(`ğŸ“ ì‹¤íŒ¨í•œ íŒŒì¼: ${result.media_file}`);
    return null;
  }
}

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    console.log('ğŸ¯ AUTO-CLIPS API í˜¸ì¶œë¨!');
    console.log(`ğŸ“¥ ë°›ì€ ë°ì´í„°:`, { sentence_results_count: data.sentence_results?.length || 0 });

    if (!data.sentence_results || !Array.isArray(data.sentence_results)) {
      return NextResponse.json({ error: 'sentence_resultsê°€ í•„ìš”í•©ë‹ˆë‹¤.' }, { status: 400 });
    }

    const allResults: SearchResult[] = [];
    
    // ëª¨ë“  ê²€ìƒ‰ ê²°ê³¼ë¥¼ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ ìˆ˜ì§‘
    data.sentence_results.forEach((sentenceResult: any, index: number) => {
      console.log(`ğŸ“ ë¬¸ì¥ ${index + 1}: "${sentenceResult.search_sentence}" - ${sentenceResult.results?.length || 0}ê°œ ê²°ê³¼`);
      
      if (sentenceResult.results && Array.isArray(sentenceResult.results)) {
        sentenceResult.results.forEach((result: SearchResult, resultIndex: number) => {
          console.log(`   ê²°ê³¼ ${resultIndex + 1}: ${result.media_file} (${result.start_time} ~ ${result.end_time})`);
          allResults.push({
            ...result,
            sentence: sentenceResult.search_sentence // ì›ë³¸ ê²€ìƒ‰ ë¬¸ì¥ ì¶”ê°€
          });
        });
      }
    });

    console.log(`ğŸ¬ ì´ ${allResults.length}ê°œ í´ë¦½ ìƒì„± ì‹œì‘ - 3ë‹¨ê³„ ë°°ì¹˜ ì²˜ë¦¬`);
    console.log(`â° ì‹œì‘ ì‹œê°„: ${new Date().toLocaleTimeString()}`);

    // ì¤‘ë³µ ì œê±° (ë™ì¼í•œ ë¯¸ë””ì–´ íŒŒì¼ + ì‹œê°„ëŒ€)
    const processedClips = new Set<string>();
    const uniqueResults: SearchResult[] = [];

    for (const result of allResults) {
      const clipKey = `${result.media_file}|${result.start_time}|${result.end_time}`;
      
      if (processedClips.has(clipKey)) {
        console.log(`ğŸ”„ ì¤‘ë³µ í´ë¦½ ê±´ë„ˆë›°ê¸°: ${result.media_file} (${result.start_time} ~ ${result.end_time})`);
        continue;
      }
      
      processedClips.add(clipKey);
      uniqueResults.push(result);
    }

    console.log(`ğŸ“Š ì¤‘ë³µ ì œê±° í›„: ${uniqueResults.length}ê°œ í´ë¦½ (${allResults.length - uniqueResults.length}ê°œ ì¤‘ë³µ ì œê±°)`);

    // ğŸ”¥ 3ë‹¨ê³„ ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘
    const batchStartTime = Date.now();
    
    // ===== 1ë‹¨ê³„: JSON ë©”íƒ€ë°ì´í„° ì¼ê´„ ìƒì„± =====
    console.log(`\nğŸ—ï¸ === 1ë‹¨ê³„: JSON ë©”íƒ€ë°ì´í„° ì¼ê´„ ìƒì„± (${uniqueResults.length}ê°œ) ===`);
    const stage1StartTime = Date.now();
    
    const jsonResults = await createJSONBatch(uniqueResults);
    const stage1Time = Date.now() - stage1StartTime;
    
    console.log(`âœ… 1ë‹¨ê³„ ì™„ë£Œ: ${jsonResults.length}ê°œ JSON ìƒì„± (ì†Œìš”ì‹œê°„: ${stage1Time/1000}ì´ˆ)`);
    
    // ===== 2ë‹¨ê³„: ì¸ë„¤ì¼ ì¼ê´„ ìƒì„± =====
    console.log(`\nğŸ“¸ === 2ë‹¨ê³„: ì¸ë„¤ì¼ ì¼ê´„ ìƒì„± (${jsonResults.length}ê°œ) ===`);
    const stage2StartTime = Date.now();
    
    const thumbnailResults = await createThumbnailBatch(jsonResults);
    const stage2Time = Date.now() - stage2StartTime;
    
    console.log(`âœ… 2ë‹¨ê³„ ì™„ë£Œ: ${thumbnailResults.success}ê°œ ì¸ë„¤ì¼ ìƒì„±, ${thumbnailResults.failed}ê°œ ì‹¤íŒ¨ (ì†Œìš”ì‹œê°„: ${stage2Time/1000}ì´ˆ)`);
    
    // ===== 3ë‹¨ê³„: ì˜ìƒ í´ë¦½ ì¼ê´„ ìƒì„± =====
    console.log(`\nğŸ¬ === 3ë‹¨ê³„: ì˜ìƒ í´ë¦½ ì¼ê´„ ìƒì„± (${jsonResults.length}ê°œ) ===`);
    const stage3StartTime = Date.now();
    
    const clipResults = await createClipBatch(jsonResults);
    const stage3Time = Date.now() - stage3StartTime;
    
    console.log(`âœ… 3ë‹¨ê³„ ì™„ë£Œ: ${clipResults.success}ê°œ í´ë¦½ ìƒì„±, ${clipResults.failed}ê°œ ì‹¤íŒ¨ (ì†Œìš”ì‹œê°„: ${stage3Time/1000}ì´ˆ)`);
    
    // ìµœì¢… ê²°ê³¼ ì •ë¦¬
    const totalTime = Date.now() - batchStartTime;
    console.log(`\nğŸ‰ === 3ë‹¨ê³„ ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ ===`);
    console.log(`ğŸ“Š ì´ ì²˜ë¦¬ ì‹œê°„: ${totalTime/1000}ì´ˆ`);
    console.log(`   - 1ë‹¨ê³„ (JSON): ${stage1Time/1000}ì´ˆ`);
    console.log(`   - 2ë‹¨ê³„ (ì¸ë„¤ì¼): ${stage2Time/1000}ì´ˆ`);
    console.log(`   - 3ë‹¨ê³„ (í´ë¦½): ${stage3Time/1000}ì´ˆ`);
    console.log(`ğŸ“ˆ ì„±ê³µë¥ : JSON ${jsonResults.length}ê°œ, ì¸ë„¤ì¼ ${thumbnailResults.success}ê°œ, í´ë¦½ ${clipResults.success}ê°œ`);
    console.log(`â° ì™„ë£Œ ì‹œê°„: ${new Date().toLocaleTimeString()}`);

    return NextResponse.json({
      success: true,
      message: `3ë‹¨ê³„ ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ`,
      total_created: clipResults.success, // í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ì‚¬ìš©í•˜ëŠ” í•„ë“œ
      total_processed: jsonResults.length, // í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ì‚¬ìš©í•˜ëŠ” í•„ë“œ
      stats: {
        total_requested: allResults.length,
        duplicates_removed: allResults.length - uniqueResults.length,
        json_created: jsonResults.length,
        thumbnails_created: thumbnailResults.success,
        clips_created: clipResults.success,
        total_time_seconds: totalTime / 1000,
        stage_times: {
          json: stage1Time / 1000,
          thumbnails: stage2Time / 1000,
          clips: stage3Time / 1000
        }
      }
    });

  } catch (error) {
    console.error('âŒ AUTO-CLIPS API ì˜¤ë¥˜:', error);
    return NextResponse.json({ 
      error: 'í´ë¦½ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      details: error instanceof Error ? error.message : String(error)
    }, { status: 500 });
  }
}

// ===== 1ë‹¨ê³„: JSON ë©”íƒ€ë°ì´í„° ì¼ê´„ ìƒì„± =====
async function createJSONBatch(results: SearchResult[]): Promise<ClipMetadata[]> {
  const jsonResults: ClipMetadata[] = [];
  
  // ê¸°ì¡´ í´ë¦½ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
  const clipsDir = MEDIA_CONFIG.CLIPS_OUTPUT_PATH;
  const existingFiles = await fs.promises.readdir(clipsDir).catch(() => []);
  const existingMetadata: ClipMetadata[] = [];
  
  for (const file of existingFiles) {
    if (file.endsWith('.json')) {
      try {
        const metadataPath = path.join(clipsDir, file);
        const metadata = JSON.parse(await fs.promises.readFile(metadataPath, 'utf-8'));
        existingMetadata.push(metadata);
      } catch {
        continue;
      }
    }
  }
  
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    console.log(`ğŸ“ JSON ìƒì„± ${i + 1}/${results.length}: ${result.media_file}`);
    
    // ë¬¸ì œ íŒŒì¼ ìŠ¤í‚µ
    const fileName = path.basename(result.media_file);
    if (PROBLEMATIC_FILES.includes(fileName)) {
      console.log(`âš ï¸ ë¬¸ì œ íŒŒì¼ ìŠ¤í‚µ: ${fileName} (ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ë“±ë¡ë¨)`);
      continue;
    }
    
    // ì¤‘ë³µ í™•ì¸
    const isDuplicate = existingMetadata.some(existing => 
      existing.sourceFile === result.media_file &&
      existing.startTime === result.start_time &&
      existing.endTime === result.end_time
    );
    
    if (isDuplicate) {
      console.log(`ğŸ”„ ê¸°ì¡´ í´ë¦½ ë°œê²¬, ê±´ë„ˆë›°ê¸°: ${result.media_file}`);
      continue;
    }
    
    // ë¯¸ë””ì–´ íŒŒì¼ ì¡´ì¬ í™•ì¸
    const mediaFilePath = getMediaFilePath(result.media_file, result.directory);
    try {
      const stats = await fs.promises.stat(mediaFilePath);
      if (!stats.isFile()) {
        console.log(`âŒ íŒŒì¼ì´ ì•„ë‹˜: ${mediaFilePath}`);
        continue;
      }
      
      // íŒŒì¼ í¬ê¸° í™•ì¸ (ë„ˆë¬´ í° íŒŒì¼ ìŠ¤í‚µ)
      const fileSizeMB = stats.size / 1024 / 1024;
      if (fileSizeMB > 3000) { // 3GB ì´ìƒ íŒŒì¼ ìŠ¤í‚µ
        console.log(`âš ï¸ íŒŒì¼ í¬ê¸° ì´ˆê³¼ ìŠ¤í‚µ: ${mediaFilePath} (${Math.round(fileSizeMB)}MB)`);
        continue;
      }
      
      console.log(`âœ… íŒŒì¼ í™•ì¸: ${mediaFilePath} (${Math.round(fileSizeMB)}MB)`);
    } catch (error) {
      console.log(`âŒ íŒŒì¼ ì—†ìŒ: ${mediaFilePath}`);
      continue;
    }
    
    // JSON ë©”íƒ€ë°ì´í„° ìƒì„±
    const clipId = uuidv4();
    const title = extractTitle(result.media_file);
    const metadataPath = path.join(MEDIA_CONFIG.CLIPS_OUTPUT_PATH, `${clipId}.json`);
    
    const metadata: ClipMetadata = {
      id: clipId,
      title,
      sentence: result.subtitle_text,
      englishSubtitle: result.subtitle_text,
      koreanSubtitle: `í•œê¸€ ë²ˆì—­: ${result.sentence || ''}`,
      startTime: result.start_time,
      endTime: result.end_time,
      sourceFile: result.media_file,
      clipPath: getClipWebPath(clipId),
      thumbnailPath: undefined, // 2ë‹¨ê³„ì—ì„œ ìƒì„±
      createdAt: new Date().toISOString(),
      duration: `${timeToSeconds(result.end_time) - timeToSeconds(result.start_time)}ì´ˆ`,
      tags: [title.split(' ')[0], 'auto-generated', 'stage-1-json'] // 1ë‹¨ê³„ ì™„ë£Œ í‘œì‹œ
    };
    
    try {
      await fs.promises.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
      jsonResults.push(metadata);
      console.log(`âœ… JSON ìƒì„±: ${clipId}`);
    } catch (error) {
      console.log(`âŒ JSON ìƒì„± ì‹¤íŒ¨: ${error}`);
    }
  }
  
  return jsonResults;
}

// ===== 2ë‹¨ê³„: ì¸ë„¤ì¼ ì¼ê´„ ìƒì„± =====
async function createThumbnailBatch(jsonResults: ClipMetadata[]): Promise<{success: number, failed: number}> {
  const BATCH_SIZE = BATCH_CONFIG.THUMBNAIL_BATCH_SIZE; // ë™ì‹œ ì²˜ë¦¬ ê°œìˆ˜ (2ê°œë¡œ ê°ì†Œ)
  let success = 0;
  let failed = 0;
  
  // ë°°ì¹˜ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
  for (let i = 0; i < jsonResults.length; i += BATCH_SIZE) {
    const batch = jsonResults.slice(i, i + BATCH_SIZE);
    console.log(`ğŸ“¸ ì¸ë„¤ì¼ ë°°ì¹˜ ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(jsonResults.length/BATCH_SIZE)}: ${batch.length}ê°œ ì²˜ë¦¬`);
    
    const promises = batch.map(async (metadata) => {
      const thumbnailPath = getThumbnailOutputPath(metadata.id);
      const mediaFilePath = getMediaFilePath(metadata.sourceFile);
      
      console.log(`ğŸ–¼ï¸ ì¸ë„¤ì¼ ìƒì„± ì‹œì‘: ${metadata.id}`);
      const thumbnailSuccess = await createThumbnail(mediaFilePath, metadata.startTime, thumbnailPath);
      
      if (thumbnailSuccess) {
        // JSON ì—…ë°ì´íŠ¸ (stage-2-thumbnail íƒœê·¸ ì¶”ê°€)
        const updatedMetadata = {
          ...metadata,
          thumbnailPath: getThumbnailWebPath(metadata.id),
          tags: metadata.tags.filter(tag => tag !== 'stage-1-json').concat(['stage-2-thumbnail'])
        };
        
        const metadataPath = path.join(MEDIA_CONFIG.CLIPS_OUTPUT_PATH, `${metadata.id}.json`);
        await fs.promises.writeFile(metadataPath, JSON.stringify(updatedMetadata, null, 2));
        
        console.log(`âœ… ì¸ë„¤ì¼ ì™„ë£Œ: ${metadata.id}`);
        return true;
      } else {
        console.log(`âŒ ì¸ë„¤ì¼ ì‹¤íŒ¨: ${metadata.id}`);
        return false;
      }
    });
    
    const results = await Promise.all(promises);
    success += results.filter(r => r).length;
    failed += results.filter(r => !r).length;
  }
  
  return { success, failed };
}

// ===== 3ë‹¨ê³„: ì˜ìƒ í´ë¦½ ì¼ê´„ ìƒì„± =====
async function createClipBatch(jsonResults: ClipMetadata[]): Promise<{success: number, failed: number}> {
  const BATCH_SIZE = BATCH_CONFIG.CLIP_BATCH_SIZE; // ë™ì‹œ ì²˜ë¦¬ ê°œìˆ˜ (2ê°œë¡œ ê°ì†Œ)
  let success = 0;
  let failed = 0;
  
  // ë°°ì¹˜ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
  for (let i = 0; i < jsonResults.length; i += BATCH_SIZE) {
    const batch = jsonResults.slice(i, i + BATCH_SIZE);
    console.log(`ğŸ¬ í´ë¦½ ë°°ì¹˜ ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(jsonResults.length/BATCH_SIZE)}: ${batch.length}ê°œ ì²˜ë¦¬`);
    
    const promises = batch.map(async (metadata) => {
      const clipPath = getClipOutputPath(metadata.id);
      const mediaFilePath = getMediaFilePath(metadata.sourceFile);
      
      console.log(`ğŸ¬ í´ë¦½ ìƒì„± ì‹œì‘: ${metadata.id}`);
      const clipSuccess = await createClip(mediaFilePath, metadata.startTime, metadata.endTime, clipPath);
      
      if (clipSuccess) {
        // JSON ìµœì¢… ì—…ë°ì´íŠ¸ (stage-3-complete íƒœê·¸ë¡œ ë³€ê²½)
        const finalMetadata = {
          ...metadata,
          tags: metadata.tags.filter(tag => !tag.startsWith('stage-')).concat(['stage-3-complete'])
        };
        
        const metadataPath = path.join(MEDIA_CONFIG.CLIPS_OUTPUT_PATH, `${metadata.id}.json`);
        await fs.promises.writeFile(metadataPath, JSON.stringify(finalMetadata, null, 2));
        
        console.log(`âœ… í´ë¦½ ì™„ë£Œ: ${metadata.id}`);
        return true;
      } else {
        console.log(`âŒ í´ë¦½ ì‹¤íŒ¨: ${metadata.id}`);
        
        // ì‹¤íŒ¨ ì‹œ JSONì— ì‹¤íŒ¨ í‘œì‹œ
        const failedMetadata = {
          ...metadata,
          tags: metadata.tags.filter(tag => !tag.startsWith('stage-')).concat(['stage-3-failed'])
        };
        
        const metadataPath = path.join(MEDIA_CONFIG.CLIPS_OUTPUT_PATH, `${metadata.id}.json`);
        await fs.promises.writeFile(metadataPath, JSON.stringify(failedMetadata, null, 2));
        
        return false;
      }
    });
    
    const results = await Promise.all(promises);
    success += results.filter(r => r).length;
    failed += results.filter(r => !r).length;
  }
  
  return { success, failed };
}
